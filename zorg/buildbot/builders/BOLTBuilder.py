from buildbot.plugins import steps
from buildbot.process.build import Build
from buildbot.process.results import SUCCESS, FAILURE, WARNINGS, SKIPPED, EXCEPTION, RETRY, CANCELLED
from buildbot.steps.shell import ShellCommand
from twisted.internet import defer
from zorg.buildbot.builders.UnifiedTreeBuilder import getLLVMBuildFactoryAndSourcecodeSteps, addCmakeSteps, addNinjaSteps
from zorg.buildbot.commands.LitTestCommand import LitTestCommand
from zorg.buildbot.commands.CmakeCommand import CmakeCommand
from zorg.buildbot.conditions.FileConditions import FileDoesNotExist
from zorg.buildbot.process.factory import LLVMBuildFactory

def getBOLTCmakeBuildFactory(
           clean = False,
           bolttests = False,
           is_nfc = False,
           targets = None,
           checks = None,
           caches = None,
           extra_configure_args = None,
           env = None,
           depends_on_projects = None,
           **kwargs):

    if env is None:
        env = {'CCACHE_COMPILERCHECK': 'content'}

    bolttests_dir = "bolt-tests"

    cleanBuildRequested = lambda step: clean or step.build.getProperty("clean") or step.build.getProperty("clean_obj")
    cleanBuildRequestedByProperty = lambda step: step.build.getProperty("clean")

    if not targets:
        targets = ['bolt']
    if not checks:
        checks = ['check-bolt']

    f = getLLVMBuildFactoryAndSourcecodeSteps(
            depends_on_projects=depends_on_projects,
            **kwargs) # Pass through all the extra arguments.

    f.buildClass = SkipAwareBuild
    if bolttests:
        checks += ['check-large-bolt']
        extra_configure_args += [
            '-DLLVM_EXTERNAL_PROJECTS=bolttests',
            '-DLLVM_EXTERNAL_BOLTTESTS_SOURCE_DIR=' + LLVMBuildFactory.pathRelativeTo(bolttests_dir, f.monorepo_dir),
            ]
        # Clean checkout of bolt-tests if cleanBuildRequested
        f.addSteps([
            steps.RemoveDirectory(name="BOLT large tests: clean",
                dir=bolttests_dir,
                haltOnFailure=True,
                warnOnFailure=True,
                doStepIf=cleanBuildRequestedByProperty),

            steps.Git(name="BOLT large tests: checkout",
                description="fetching",
                descriptionDone="fetch",
                descriptionSuffix="BOLT Large Tests",
                repourl='https://github.com/rafaelauler/bolt-tests.git',
                workdir=bolttests_dir,
                alwaysUseLatest=True),
            ])

    # Some options are required for this build no matter what.
    CmakeCommand.applyRequiredOptions(extra_configure_args, [
        ('-G',                      'Ninja'),
        ])

    if caches:
        for cache in caches:
            extra_configure_args += [f"-C../{f.monorepo_dir}/{cache}"]

    addCmakeSteps(
        f,
        cleanBuildRequested=cleanBuildRequested,
        extra_configure_args=extra_configure_args,
        obj_dir=None,
        env=env,
        **kwargs)

    addNinjaSteps(
        f,
        targets=targets,
        checks = None if is_nfc else checks,
        env=env,
        **kwargs)

    """
    In NFC mode we conditionally run tests only when the llvm-bolt binary has
    changed between the previous and current revision. We skipped passing checks
    to addNinjaSteps, so we add those checks below, along with the conditional
    logic.
    """
    if is_nfc:
        # Marker for relevant source code changes, e.g., when updating tests.
        # Generated by nfc-check-setup.py and used to trigger the in-tree tests.
        hasSrcChanges = ".llvm-bolt.changes"
        # Individual markers to skip either in-tree or out-of-tree tests.
        skipInTree = ".llvm-bolt.skip.in-tree"
        skipOutOfTree = ".llvm-bolt.skip.out-of-tree"
        boltNew = "bin/llvm-bolt.new"
        boltOld = "bin/llvm-bolt.old"

        f.addSteps([
            # Cleanup binaries and markers from previous NFC-mode runs.
            ShellCommand(
                name='clean-nfc-check',
                command=(
                        f"rm -f {boltNew} {boltOld} {hasSrcChanges} {skipInTree} {skipOutOfTree}; "
                        ),
                description=('Cleanup for NFC-Mode testing'),
                descriptionDone=["NFC-Mode cleanup"],
                haltOnFailure=False,
                flunkOnFailure=False,
                env=env),
            # Build the current and previous revision of llvm-bolt.
            ShellCommand(
                name='nfc-check-setup',
                command=[
                        f"../{f.monorepo_dir}/bolt/utils/nfc-check-setup.py",
                        "--switch-back",
                        "--check-bolt-sources"
                        ],
                description=('Setup NFC testing'),
                descriptionDone=["NFC-Mode setup"],
                warnOnFailure=True,
                warnOnWarnings=True,
                decodeRC={0: SUCCESS, 1: WARNINGS},
                haltOnFailure=False,
                flunkOnFailure=False,
                env=env),
            # Verify that the llvm-bolt binary can report its version within a
            # reasonable amount of time.
            ShellCommand(
                name='llvm-bolt-version-check',
                command=(f"{boltNew} --version"),
                description=('Check that llvm-bolt binary passes a simple test'
                             'before proceeding with testing.'),
                descriptionDone=["llvm-bolt --version"],
                haltOnFailure=True,
                flunkOnFailure=True,
                maxTime=30,
                env=env),
            # Validate that NFC-mode comparison is meaningful by checking:
            # - the old and new binaries exist
            # - no unique IDs are embedded in the binaries
            # Warns but does not fail when validation fails.
            ShellCommand(
                name='nfc-check-validation',
                command=(
                    f"( ! [ -f {boltNew} ] || ! [ -f {boltOld} ] ) && "
                    "{ printf 'NFC-Mode WARNING: old/new files not present. Tests will run.'; return 2; }; "
                    f"uids=$({boltNew} --version | grep 'BOLT revision' "
                    "| grep -q '<unknown>' || echo 'bolt-revision'); "
                    f"uids=$uids$(readelf --notes {boltNew} "
                    "| grep -q 'Build ID:' && echo ' GNU-build-id'); "
                    "uids=$(echo \"$uids\" | sed 's/^ //'); "
                   f"[ $(readelf --note {boltNew} {boltOld} | grep 'Build ID' | uniq -c | wc -l) -eq 1 ] "
                    "&& extra='Identical build-ids.' || extra='Tests will run.'; "
                    "[ ! -z \"$uids\" ] || return 0 && "
                    "{ printf \"NFC-Mode WARNING: unique IDs found in binaries ($uids). $extra\"; return 2; }"
                    ),
                description=('Check that nfc-mode works as intended when '
                             'comparing with the previous commit.'),
                haltOnFailure=False,
                warnOnFailure=True,
                warnOnWarnings=True,
                maxTime=30,
                decodeRC={0: SUCCESS, 1: FAILURE, 2: WARNINGS},
                descriptionDone=["NFC-Mode Validation"],
                env=env),
            # Compare the current and previous llvm-bolt binaries. If they are
            # identical, skip the following tests. If relevant source code
            # changes are detected, still run the in-tree tests.
            ShellCommand(
                name='nfc-check-bolt-different',
                command=(
                          f'cmp -s {boltNew} {boltOld} && ('
                          f'touch {skipInTree}; touch {skipOutOfTree}); '
                          f'[ -f {hasSrcChanges} ] && rm -f {skipInTree}; '
                          f'return 0'
                         ),
                description=('Check if llvm-bolt binaries are different and '
                             'skip the following nfc-check steps'),
                decodeRC={0: SUCCESS, 1: WARNINGS},
                haltOnFailure=False,
                env=env),
            # Run in-tree tests if the llvm-bolt binary has changed, or if
            # relevant source code changes are detected. Lower scheduling
            # priority with nice to reduce CPU contention in virtualized
            # environments.
            LitTestCommand(
                name='nfc-check-bolt',
                command=("nice -n 5 ninja check-bolt"),
                description=["running", "NFC", "check-bolt"],
                descriptionDone=["NFC", "check-bolt", "completed"],
                warnOnFailure=True,
                haltOnFailure=False,
                flunkOnFailure=True,
                doStepIf=FileDoesNotExist(f"build/{skipInTree}"),
                env=env),
            # Run out-of-tree large tests if the llvm-bolt binary has changed.
            # Lower scheduling priority, as above.
            LitTestCommand(
                name='nfc-check-large-bolt',
                command=('nice -n 5 bin/llvm-lit -sv -j2 tools/bolttests'),
                description=["running", "NFC", "check-large-bolt"],
                descriptionDone=["NFC", "check-large-bolt", "completed"],
                warnOnFailure=True,
                haltOnFailure=False,
                flunkOnFailure=True,
                doStepIf=FileDoesNotExist(f"build/{skipOutOfTree}"),
                env=env),
            ])

    return f

class SkipAwareBuild(Build):
    """
    Custom Build class that marks the overall build status as skipped when no
    BOLT tests have run and no other important statuses are logged.

    This is done by overriding stepDone, which merges the results of each step
    to the overall build.
    """
    @defer.inlineCallbacks
    def stepDone(self, results, step):
        # Run the default logic.
        terminate = yield Build.stepDone(self, results, step)

        # Specialize by setting the overall build result to skipped when no
        # tests have ran and no other errors occurred.
        if step.name == "nfc-check-bolt" and results == SKIPPED and self.results not in (FAILURE, WARNINGS, EXCEPTION, RETRY, CANCELLED):
            self.results = SKIPPED
        return terminate
